> ## JVM虚拟机与JMM内存模型

## JVM内存模型(介绍下 Java 内存区域/运行时数据区)? 程序计数器, 栈, 堆, 方法区?
## JDK1.7之前常量池在哪里? 之后在哪里?
## JDK1.8永久代变为了什么?
## Java内存模式对final的实现? 什么是引用逃逸?
## 什么是元空间?
## Java基本类型、引用类型在内存中的存储原理?
## JVM如何判断两个类是否相同?
类全限定名和类加载器

## 分析 `Object obj = new Object();` 对象创建过程?
## `String.intern()`?
## `String s = new String("abc");`创建了几个对象?
## 栈中对象引用有几种方法? 详细介绍一下区别? 
## JVM年轻代与老年代? 年轻代垃圾回收过程? 
## 永久代会发生垃圾回收吗?
## JVM年轻代中Eden与survivor的比例?
8:1
## 垃圾回收算法有哪些?
## 垃圾回收策略?
## 垃圾收集器有哪些? CMS特点?
## CMS中什么是浮动垃圾?
## 比较一下G1与CMS?
## 整个JVM大小?
## 年老代堆空间被占满如何解决? 持久代被占满如何解决? 堆栈溢出如何解决?
## 如何解决异常Fatal: Stack size too small?
## 如何解决异常java.lang.OutOfMemoryError: unable to create new native thread?
## JMM内存模型中的规定了哪八种操作? 什么是重排序?
## 内存模型三大特性? 原子性、可见性、有序性如何实现?
## 堆上的内存如何释放, 栈上的内容如何释放?
## Java内存泄露的最直接表现? 
## 什么是内存溢出, 什么是内存泄露? Java会不会发生内存泄露?
## 什么情况下会发生内存溢出?
## 老年代溢出原因? 永久代溢出原因?
## 如果对象的引用被置为null, 垃圾回收器是否会立即释放该对象占用的内存?
## Java中对象什么时候可以被垃圾回收?
## 你能保证GC吗?
## finalize什么时候使用? 为什么避免使用? 
## JVM如何确定一个对象是不是有引用?
## GC Roots包含哪些?
## GC Roots 对不可用对象的判断过程?
## 什么时候新生代会发生GC? 老年代发生GC条件? Full GC 触发条件? +
## 永久代回收条件?
## GC为什么要分代?
## JVM中大对象被分配到哪里? 长期存活对象进入哪里? 什么是空间分配担保?
## 进入老年代的几种情况?
<149>
## JRE判断程序是否结束的标准?
## 什么是安全点?
## 什么是happens-before(先发行为原则)?
## 对象创建的过程?
## 对象内存布局?
## 被动引用有哪些情况?
## 静态解析和动态解析?
## 静态分配和动态分配?

