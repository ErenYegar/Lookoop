> ## 集合问题

## 线程同步的集合有哪些?
Vector, Stack, HashTable, Enumeration

## 哪些类实现了Collection接口?
List, Stack, Queue,Set

## 为什么集合没有实现Cloneable和Serializable?
## Iterator和ListIterator区别? 
## Enumeration接口和Iterator接口的区别?
## 快速失败(fail-fast)和安全失败(fail-safe)区别? 
## 数组和列表有什么区别? 如何选择
## ArrayList与LinkedList区别? 底层原理? ArrayList扩容、删除如何实现?
## LinkedList适合什么排序?
## 用过哪些Map类, 都有神马区别? HashMap实现过程(JDK1.8)? put、扩充等实现过程? 
HashMap, TreeMap(不允许null键), HashTable, LinkedHashMap, IdentityMap, WeakMap, EnumeMap

## 为什么HashMap里数组使用transient修饰?
不使用默认序列化方法, 自己有一个序列化方法

## HashMap的长度为什么是2的幂次方?
寻找桶位置时是`hash & (length - 1)`, 这样更加有效地利用每个位

## HashMap链表插入是头插入还是尾插入? 头插入会造成什么问题? 
JDK1.7是使用头插入; JDK1.8开始使用尾插入, 在尾部添加一个tail指针。
头插入在进行扩展时可能会形成闭环。

## HashMap为什么用红黑树而不用AVL树?
红黑树更适合插入修改密集型操作; AVL树因为是更加严格的平衡, 适用于查找型操作; 通常AVL旋转比红黑树更难以平衡和调试

## concurrentHashMap实现原理? JDK1.7与JDK1.8区别?
- JDK1.7: 使用Segment, HashEntry, ReentranLock
- JDK1.8: 使用Node, CAS, Synchronized
put()操作步骤: 
1. 先判断键值是否为空, 若为空则返回
2. 获得键的哈希值, 然后进入一个无限循环
3. 循环中第一步先判断数组是否为空, 若为空初始化数组, 进入下一个循环
4. 判断是否需要扩充
5. 判断桶所在位置是否为空, 若为空则使用CAS操作将数据插入
6. 若有数据, 则用syncronized锁住该桶的第一个数据
7. 若为链表, 若重复则更新值, 否则添加到链表末尾
8. 若为树, 按照树的插入操作进行插入
9. 插入数据后判断链表长度是否大于转换阈值8, 若大于8则需要将链表转换为红黑树
10. 更新数据记录, 返回

## HashTable和HashMap的区别?
## HashTable和concurrentHashMap的区别?
## HashSet, TreeSet, LinkedHashSet之间的区别? HashSet内部原理?
HashSet基于HashMap 
## 阻塞队列, ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, DelayQueue, SynchronousQueue各自特点? 非阻塞队列? 
## 阻塞队列的插入、移除方法?
阻塞方法: put(), take()